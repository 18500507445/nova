## 3.类和接口

### 3.1类和成员的访问修饰权限最小化
1. 良好的设计应该只暴露需要暴露的方法，只暴露给需要的类
2. 对于使用者只需要查看能访问到的信息，不需要关注其他的内部细节同时也避免了外部类的误操作导致的问题
3. 就像本项目effective目录下多个Cat，但是每个测试类只能用同目录下的，避免例子串了
- private：私有的，只有小类可以访问（内部类可以访问外部类的私有）  
- 无修饰符：包级别私有，本包内可以访问  
- protected：子类＋包级   
- public：无限制，所有可访问

### 3.2使用getter、setter代替public属性(公有方法代替公有属性)
1. 如果一个类需要对外提供某些属性，不要直接使用public属性字段而是属性私有化，对外提供getter、setter
2. 共有属性直接操作时无法进行安全检查，而getter、setter方法可以灵活地进行重构升级，也可以在操作前进行安全检查

### 3.3使可变性最小化(最好是不可变类)
1. 不可变指的是类的实例不可变，其所包含的信息在初始化之后就不会再发生变化.jdk中提供了很多类都是不可变类String、Integer
2. 不可变类更容易设计使用，更加安全，也不会有线程并发问题
- 比如jdk中String不可变，因此jvm可以为他设计字符串池，并且HashMap等工具类也可以放心使用 String作为key  
- Integer不可变，因此可以设计—128～127的缓存，这样可以降低jvm的gc不可变类只需要考虑初始化时候的所有属性状态，而可变类需要随时考虑各种属性的可能变化，是否线程安全等问题，因此如果可以，设计为不可变类更安全高效，也更不容易出bug
3. 设计不可变类，有些需要注意的点
- 不要提供修改状态的方法 既然是不可变类，当然不应该提供修改状态的方法，如果需要其他状态，应该使用新的实例
- 避免类的扩展 如果类被子类继承，则可能部分行为被覆盖，这种情况是对不可变的破坏，应该避免此类被扩展，最简单直接的方式就是使用 final 修饰类，禁止继承.当然也可以有其他方式，比如说，构造器私有化，通过静态方法对外提供实例，因为私有方法不能被外部访问（包括子类），这样虽然没有final 修饰，但实际上也成了final类
- 属性final化对于一些关键的属性，设置为final，避免属性被修改
- 属性 private 化将属性私有化，可以避免外部直接操作，同时私有化之后可以更好处理未来的变化（公有的属性可能被任何外部类所使用，这会导致未来升级时，如果要保持兼容性，必须永远保留这个公有属性）
- 对可变组件的互斥访问如果类中有指向和使用可变对象，则不应该向调用者返回这些引用，也不能使用客户端提供的对象来初始化，也不要从任何访问方法中返回此引用.总之，如果不可变类使用了可变对象，应该保证自己不被这些可变所影响／在构造器，访问方法和 readObject 中使用保护性拷贝
- （额外）数组和容器等尽量避免 getter方法，尽量避免在任何方法中返回这些对象这一条实际上是对上一条的补充，本质上是上一条的内容，这里额外说一下，因为数组和容器这些 即便本身没有发生变化，如果你返回了引用，则可能被外部程序修改元素请参考StringBuilder和String的关系，对于不可变性和可变性的处理
- （额外）很多时候，坚固的堡垒却是被内部攻破，所以要注意一点，在避免上面的问题后，也要提醒自己，内部也不要修改属性和引用的信息

### 3.3复合优于继承

