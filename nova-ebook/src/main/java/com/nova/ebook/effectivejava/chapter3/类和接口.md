## 3.类和接口

### 3.1类和成员的访问修饰权限最小化
1. 良好的设计应该只暴露需要暴露的方法，只暴露给需要的类
2. 对于使用者只需要查看能访问到的信息，不需要关注其他的内部细节同时也避免了外部类的误操作导致的问题
3. 就像本项目effective目录下多个Cat，但是每个测试类只能用同目录下的，避免例子串了
- private：私有的，只有小类可以访问（内部类可以访问外部类的私有）  
- 无修饰符：包级别私有，本包内可以访问  
- protected：子类＋包级   
- public：无限制，所有可访问

### 3.2使用getter、setter代替public属性(公有方法代替公有属性)
1. 如果一个类需要对外提供某些属性，不要直接使用public属性字段而是属性私有化，对外提供getter、setter
2. 共有属性直接操作时无法进行安全检查，而getter、setter方法可以灵活地进行重构升级，也可以在操作前进行安全检查

### 3.3使可变性最小化(最好是不可变类)
1. 不可变指的是类的实例不可变，其所包含的信息在初始化之后就不会再发生变化.jdk中提供了很多类都是不可变类String、Integer
2. 不可变类更容易设计使用，更加安全，也不会有线程并发问题
- 比如jdk中String不可变，因此jvm可以为他设计字符串池，并且HashMap等工具类也可以放心使用 String作为key  
- Integer不可变，因此可以设计—128～127的缓存，这样可以降低jvm的gc不可变类只需要考虑初始化时候的所有属性状态，而可变类需要随时考虑各种属性的可能变化，是否线程安全等问题，因此如果可以，设计为不可变类更安全高效，也更不容易出bug
3. 设计不可变类，有些需要注意的点
- 不要提供修改状态的方法 既然是不可变类，当然不应该提供修改状态的方法，如果需要其他状态，应该使用新的实例
- 避免类的扩展 如果类被子类继承，则可能部分行为被覆盖，这种情况是对不可变的破坏，应该避免此类被扩展，最简单直接的方式就是使用 final 修饰类，禁止继承.当然也可以有其他方式，比如说，构造器私有化，通过静态方法对外提供实例，因为私有方法不能被外部访问（包括子类），这样虽然没有final 修饰，但实际上也成了final类
- 属性final化对于一些关键的属性，设置为final，避免属性被修改
- 属性 private 化将属性私有化，可以避免外部直接操作，同时私有化之后可以更好处理未来的变化（公有的属性可能被任何外部类所使用，这会导致未来升级时，如果要保持兼容性，必须永远保留这个公有属性）
- 对可变组件的互斥访问如果类中有指向和使用可变对象，则不应该向调用者返回这些引用，也不能使用客户端提供的对象来初始化，也不要从任何访问方法中返回此引用.总之，如果不可变类使用了可变对象，应该保证自己不被这些可变所影响／在构造器，访问方法和 readObject 中使用保护性拷贝
- （额外）数组和容器等尽量避免 getter方法，尽量避免在任何方法中返回这些对象这一条实际上是对上一条的补充，本质上是上一条的内容，这里额外说一下，因为数组和容器这些 即便本身没有发生变化，如果你返回了引用，则可能被外部程序修改元素请参考StringBuilder和String的关系，对于不可变性和可变性的处理
- （额外）很多时候，坚固的堡垒却是被内部攻破，所以要注意一点，在避免上面的问题后，也要提醒自己，内部也不要修改属性和引用的信息

### 3.4复合优于继承
1. 继承是面向对象编程的重要特点，使用继承可以让我们方便地重用代码，但继承并不是适用于所有情况的，相反的是可能更多时候，复合比继承更合适
- 继承会破坏封装性（子类的某些特定功能可能依赖于父类的实现，而这样会导致父类的封装性被破坏，要么子类需要注意每一次父类的变化版本，要么父类被约束不能更新）
2. 比如我们使用的List Map Set等，如果要添加一个统计添加次数的功能因为原始类中没有，这时候如果我们用继承的方法去实现

### 3.5要么为继承而设计，并提供文档说明，要么就禁用继承
1. 继承是传播性的，使用继承必须考虑到所有的super中是否有影响  
2. 合理暴露方法，需要认真设计好哪些方法应该是private 哪些protected 哪些 public，因为任何public和protected方法都可能被继承（除非你声明final禁止指定方法被覆盖）  
3. 方法之间如果有顺序或者依赖性，要考虑被覆盖后，是否会导致问题出现  
4. 文档说明要及时准确，否则可能导致使用者错误的使用  

- 继承当然不是一无是处，因为大部分情况下，我们的工作是小组的形式，而每个人有自己的大概维护范围，同时你也可以很方便找到他们，
继承的缺点其实也不是一定会那么大，比如我们就经常设计BaseDao，BaseService，
包括jdk也有非常多的继承的类，以上的说明只是帮我们认识到继承体系在极端情况下可能带来的问题，对这些东西有个心理预期
- 总之，合理利用继承，知道某些（很多）情况下，复合同样也可以解决我们的问题，不要只知道继承就可以了

### 3.6接口优于抽象类(建议性)


### 3.7


### 3.8




