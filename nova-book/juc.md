## Java并发编程
### 1. 进程与线程
#### 1.1 进程与线程
进程
- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等）

线程
- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行
- Java中，线程作为最小调度单位，进程作为资源分配的最小单位。 在windows中进程是不活动的，只是作为线程的容器

二者对比
- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂，（1）同一台计算机的进程通信称为 IPC（Inter-process communication），（2）不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

#### 1.2 并行与并发
> 单核cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为15毫秒）分给不同的程序使用，  
只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。  
总结为一句话就是：微观串行，宏观并行，一般会将这种线程轮流使用CPU的做法称为并发，concurrent

> 多核cpu下，每个核（core）都可以调度运行线程，这时候线程可以是并行的。

引用RobPike（golang语言创造者）的一段描述：
- 并发（concurrent）是同一时间应对（dealing with）多件事情的能力
- 并行（parallel）是同一时间动手做（doing）多件事情的能力

例子
- 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发
- 家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）
- 雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行

#### 1.3 应用
> 多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了5秒钟，
> 如果没有线程调度机制，这5秒cpu什么都做不了，其它代码都得暂停...

应用之异步调用
- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步


### 2. Java线程
#### 2.1 创建和运行线程
原理之Thread与Runnable的关系
- 方法demoA是把线程和任务合并在了一起，方法demoB是把线程和任务分开了
- 用Runnable更容易与线程池等高级API配合
- 用Runnable让任务类脱离了Thread继承体系，更灵活

#### 2.2 观察多个线程同时运行
见section2例子

#### 2.3 查看进程方法
linux
- ps -fe 查看所有进程
- ps -fT -p <PID> 查看某个进程（PID）的所有线程
- kill 杀死进程
- top 按大写 H 切换是否显示线程
- top -H -p <PID> 查看某个进程（PID）的所有线程

#### 2.4线程运行原理
![线程运行原理](https://img-blog.csdnimg.cn/784158a11c924f4c9e376e12a37ebe6b.png#pic_center)
栈与栈帧
> Java Virtual Machine Stacks （Java虚拟机栈）
我们都知道JVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存
> - 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
> - 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

线程上下文切换（Thread Context Switch）
> 因为以下一些原因导致cpu不再执行当前的线程，转而执行另一个线程的代码
> - 线程的cpu时间片用完
> - 垃圾回收
> - 有更高优先级的线程需要运行
> - 线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法

> 当ContextSwitch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念
就是程序计数器（ProgramCounterRegister），它的作用是记住下一条jvm指令的执行地址，是线程私有的
> - 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等
> - Context Switch频繁发生会影响性能