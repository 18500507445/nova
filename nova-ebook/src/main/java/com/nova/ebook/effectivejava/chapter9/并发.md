## 9.并发

### 9.1同步访问共享的可变数据
1. 关键字synchronized 可以保证在同一时刻，只有一个线程可以执行某一个方法，或者某一段代码块。许多程序员把同步的概念仅仅理解为一种互斥的方式。即，当一个对象被一个线程修改的时候，可以阻止另一个线程观察到内部不一致的状态。按照这种观点，对象被创建的时候处于一致的状态，当有方法访问它的时候，它就被锁定了。这些方法观察到对象的状态，并且可能引起状态转变，即把对象从一种一致的状态转换到另一种一致的状态。正确地使用同步可以保证没有任何方法不会看到对象处于不一致的状态中。
2. 这种观点是正确的，但是它并没有说明同步的全部意义。如果没有同步，一个线程的变化就不能被其他线程看到。同步不仅可以阻止一个线程看到对象处于不一致的状态之中，它还可以保证进入同步方法或代码块的每个线程，都看到由一个同步锁保护的之前所有的修改效果。
3. java语言规范保证 读或者写一个变量是原子的（atomic），除非这个变量的类型为long或者 double（它们是双精度）。换言之，读取一个非long或double类型的变量，可以保证返回的值是某个线程保存在该变量中的，即使多个线程在没有同步的情况下并发地修改这个变量也是如此。注意，只能保证你读取到的是某一个时刻的值，并不能保证是哪一个时刻。可能A先写，B后读，但B读取到的是A写之前的状态，这是因为还没有来得及同步
4. 你可能听说过，为了提高性能，在读或者写原子数据的时候，应该避免使用同步。这个建议是非常危险而错误的。虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。为了在线程间进行可靠的通信，也为了互斥访问，同步是必要的。这归因于java语言规范中的内存模型，它规定了一个线程所做的变化何时以及如何变成对其他线程可见。
5. 如果对共享的可变数据的访问不能同步，其后果将非常可怕，即使这个变量是原子可读写的。

### 9.2避免过度同步
1. 上一条说明了丢失同步的危险性，本条目则关注进一步优化。如果过度使用同步，可能导致性能降低，甚至死锁或不确定的行为。
2. 为了避免此类问题，在同步方法或代码块中，永远不要放弃对客户端的控制。换言之，在一个同步方法中，不要调用设计成要被覆盖的方法，或者由客户端以函数对象的形式提供的方法（ps：包括jdk8之后的lambda形式）。从包含该同步区域的类的角度来看，这样的方法是外来的。这个类不知道该方法会做什么事情，也无法控制它。根据外来方法的作用，从同步区域中调用它可能会导致异常、死锁或者数据损坏。如果外部代码执行时间长，可能导致长时间持有锁，引发性能问题。
3. 尽可能在同步区域内少执行任务，最好只做必要的工作。获得锁，俭查共享数据，操作数据，释放锁。如果发现有某个计算必咬耗时，应该考虑是不是可以把它的计葺工作放在外部，只在最关健的必须和共享数据交互的部分放在同步中。

### 9.3线程池优new Thread
1. 相比较于Thread和Timer，线程池是将线程做了池化操作
2. 在java中，线程的创建和回收是比较重量级的任务，所以应该慎重对待创建多线程
3. 如果任务本身的计算量不大，那可能im中大量的空间的时间被用于执行线程创建和回收，显然对性能非常不利Executors本身已经提供了默认的4种线程池策略，用于一些常见的情况.如果有特殊情况，我们也可以自己调整参数。