## Java虚拟机

![学习路线](https://img-blog.csdnimg.cn/7cddc167f09e48319575188803688b57.png#pic_center)
 
### 1.JVM内存结构
#### 1.1 程序计数器  
（1）作用：记住下一条jvm指令地址。  
（2）特点：线程私有，抢到资源后继续执行下一条指令  
#### 1.2 虚拟机栈  
（1）数据结构中的栈，就和弹夹一样，先进后出。  
（2）java中每个线程划分的内存空间就是虚拟机栈，每个组成元素叫栈帧，一个栈帧对应一次方法的调用，也就是每个方法运行时需要的内存就是一个栈帧  

**_问题辨析_**
1. 垃圾回收是否涉及栈内存？  答：不涉及，栈内存无非就是一次次的方法调用，方法执行完毕就弹栈了。
2. 栈内存分配越大越好吗？  答：不是，栈内存-Xss（默认1Mb），总内存不变，栈内存越大，线程数越少。
3. 方法内的局部变量是否线程安全？  答：如果线程私有就是安全的
4. cpu占用过多
- top（查看哪个进程id占用cpu高）
- ps H -eo pid,tid,%cpu |grep pid（定位是哪个线程引起的）
- pid转16进制获得nid
- jstack pid（找到nid对应的行号，进一步定位源代码）

#### 1.3 本地方法栈
java调用本地方法，由C或者C++语言编写的本地方法去操作系统，例如Object类clone方法（带有native关键字）

#### 1.4 堆(Heap)
通过new关键字，创建对象都会使用堆内存
- 它是线程共享的，需要考虑线程安全问题
- 有垃圾回收机制，不再被引用的对象，释放空闲内存

**_诊断工具_**
- jmap （jdk自带）jps展示进程id，jmap -heap pid
- jconsole（jdk自带）

#### 1.5 方法区
jvm启动创建方法区

#### 1.6直接内存
![直接内存](https://img-blog.csdnimg.cn/6ba8e4fc774a4a55aa4b9f1982c5235d.png#pic_center)


### 2.垃圾回收
#### 2.1 方法区如何判断对象可以回收
可达性分析算法
- 哪些对象可以作为gc root对象（相当于一串葡萄，掉落在盘子里的是可以回收的对象）

四种引用  
强引用：用得到并且不回收  
软引用：没用到不回收，内存满了才回收  
弱引用：被发现就回收  
虚引用：弱引用+引用队列  

#### 2.2 垃圾回收算法
![标记清除](https://img-blog.csdnimg.cn/43527a2f3065445a88a8eaaa3dc698b9.png#pic_center)
- 标记清除（没有gc root引用的标记清除，优点：速度快，缺点：空间有碎片，不连续）
![标记整理](https://img-blog.csdnimg.cn/d6e26f59c6834867b64adbe0745b48df.png#pic_center)
- 标记整理（优点：整理空间碎片，内存紧凑，空间连续，缺点：移动碎片，地址重排，效率低）
![复制](https://img-blog.csdnimg.cn/1bf7a870c7bc4c3fa8beea2a23e2894e.png#pic_center)
- 复制（创建一个新的空间，把标记的拷贝过来，空间换时间，占用内存双倍空间）

#### 2.3 分代垃圾回收
![分代垃圾回收](https://img-blog.csdnimg.cn/76b2569661ff4f0ab0660f67dda60dce.png#pic_center)

![相关VM参数](https://img-blog.csdnimg.cn/26133884fe48458186725bc7bb843692.png#pic_center)

#### 2.4 垃圾回收器
- 串行 
- 吞吐量优先
- 响应时间优先
#### 2.5 垃圾回收调优