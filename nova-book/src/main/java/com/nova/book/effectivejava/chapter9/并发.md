## 9.并发

### 9.1同步访问共享的可变数据

1. 关键字synchronized
   可以保证在同一时刻，只有一个线程可以执行某一个方法，或者某一段代码块。许多程序员把同步的概念仅仅理解为一种互斥的方式。即，当一个对象被一个线程修改的时候，可以阻止另一个线程观察到内部不一致的状态。按照这种观点，对象被创建的时候处于一致的状态，当有方法访问它的时候，它就被锁定了。这些方法观察到对象的状态，并且可能引起状态转变，即把对象从一种一致的状态转换到另一种一致的状态。正确地使用同步可以保证没有任何方法不会看到对象处于不一致的状态中。
2.
这种观点是正确的，但是它并没有说明同步的全部意义。如果没有同步，一个线程的变化就不能被其他线程看到。同步不仅可以阻止一个线程看到对象处于不一致的状态之中，它还可以保证进入同步方法或代码块的每个线程，都看到由一个同步锁保护的之前所有的修改效果。
3. java语言规范保证 读或者写一个变量是原子的（atomic），除非这个变量的类型为long或者
   double（它们是双精度）。换言之，读取一个非long或double类型的变量，可以保证返回的值是某个线程保存在该变量中的，即使多个线程在没有同步的情况下并发地修改这个变量也是如此。注意，只能保证你读取到的是某一个时刻的值，并不能保证是哪一个时刻。可能A先写，B后读，但B读取到的是A写之前的状态，这是因为还没有来得及同步
4.
你可能听说过，为了提高性能，在读或者写原子数据的时候，应该避免使用同步。这个建议是非常危险而错误的。虽然语言规范保证了线程在读取原子数据的时候，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。为了在线程间进行可靠的通信，也为了互斥访问，同步是必要的。这归因于java语言规范中的内存模型，它规定了一个线程所做的变化何时以及如何变成对其他线程可见。
5. 如果对共享的可变数据的访问不能同步，其后果将非常可怕，即使这个变量是原子可读写的。

### 9.2避免过度同步

1. 上一条说明了丢失同步的危险性，本条目则关注进一步优化。如果过度使用同步，可能导致性能降低，甚至死锁或不确定的行为。
2.
为了避免此类问题，在同步方法或代码块中，永远不要放弃对客户端的控制。换言之，在一个同步方法中，不要调用设计成要被覆盖的方法，或者由客户端以函数对象的形式提供的方法（ps：包括jdk8之后的lambda形式）。从包含该同步区域的类的角度来看，这样的方法是外来的。这个类不知道该方法会做什么事情，也无法控制它。根据外来方法的作用，从同步区域中调用它可能会导致异常、死锁或者数据损坏。如果外部代码执行时间长，可能导致长时间持有锁，引发性能问题。
3. 尽可能在同步区域内少执行任务，最好只做必要的工作。获得锁，俭查共享数据，操作数据，释放锁。如果发现有某个计算必咬耗时，应该考虑是不是可以把它的计葺工作放在外部，只在最关健的必须和共享数据交互的部分放在同步中。

### 9.3线程池优new Thread

1. 相比较于Thread和Timer，线程池是将线程做了池化操作
2. 在java中，线程的创建和回收是比较重量级的任务，所以应该慎重对待创建多线程
3. 如果任务本身的计算量不大，那可能im中大量的空间的时间被用于执行线程创建和回收，显然对性能非常不利Executors本身已经提供了默认的4种线程池策略，用于一些常见的情况.如果有特殊情况，我们也可以自己调整参数。

### 9.4并发工具优于wait和notify

1. java.util.concurrent包
2. Execute Framework(线程池)、并发集合(ConcurrentHashMap、CopyOnWriteArrayList)、Synchronize
3. ConcurrentHashMap保证了速度和并发性，锁的粒度更小，作用于节点上
4. HashTable和Collections.SynchronizeMap这两个性能低，锁粒度大，直接作用于方法上
5.
有些集合已经通过阻塞操作进行了扩展它们会一直等待（阻塞）到成功执行为止.比如BlockingQueue扩展了Queue接口并添加了take在内的几个方法，它从队列中删除并返回头元素如果为空，就一直等待到有元素加入然后执行此操作.这样就允许将阻塞队列用于工作队列（workQueue），也称作生产者-消费者队列.这种工作队列是线程安全的，使用这种队列，就可以保证安全地生产和消费。大多数ExecutorService都使用BlockingQueue.如此，一边在队列尾部提交task，而线程池则从头部获取task，在线程池中执行。
6. 同步器（Synchronizer）是一些能使一些线程等待另一个（一些）线程的对象允许它们协调动作.比较常用的是CountDownLatch、Semaphore较不常用的是CyclicBarrier和Exchanger
7. Semaphore信号量，控制线程数

### 9.5线程安全性的文档化(清晰地注释)

1.
每个类都应该认真说明线程的安全性，安全等级。synchronized修饰符与此并不是等价关系，或者说不能以这个关键字作为依据。如果有外部同步，需要注明外部同步的时候需要获得哪个（哪些）锁。如果你编写的是无条件的线程安全类，考虑使用私有对象所而不是同步来实现线程安全，不仅可以防止调用者和子类的锁干扰，在后续版本中也可以灵活地处理并发问题。

### 9.6慎用延迟初始化(懒加载)

1. 延退初始化是一种优化方案。和前面提到的大多数优化情况一样，在非必要时，不要目进行所请优化，做的越多，代码越多，逻辑越复杂

### 9.7不要依赖于线程调度器(建议使用线程池)

1. 简而言之，不要让应用的正确性依赖于线程调度器。否则，结果得到的应用可能既不健壮，也不具有可移植性。
2. 作为推论，不要依赖Thread.yield或者线程优先级。
3. 这些设施紧紧对调度器做些暗示，线程优先级可以用来提高一个已经能够正常工作的程序的服务质量，但永远不应该用来"修正"
   一个原本并不能工作的程序。

### ~~9.8避免使用线程组(废弃)~~

1. ThreadGroup被放弃，直接用线程池就OK了