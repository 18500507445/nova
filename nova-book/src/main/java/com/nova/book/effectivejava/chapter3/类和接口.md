## 3.类和接口

### 3.1类和成员的访问修饰权限最小化

1. 良好的设计应该只暴露需要暴露的方法，只暴露给需要的类
2. 对于使用者只需要查看能访问到的信息，不需要关注其他的内部细节同时也避免了外部类的误操作导致的问题
3. 就像本项目effective目录下多个Cat，但是每个测试类只能用同目录下的，避免例子串了

- private：私有的，只有小类可以访问（内部类可以访问外部类的私有）
- 无修饰符：包级别私有，本包内可以访问
- protected：子类＋包级
- public：无限制，所有可访问

### 3.2使用getter、setter代替public属性(公有方法代替公有属性)

1. 如果一个类需要对外提供某些属性，不要直接使用public属性字段而是属性私有化，对外提供getter、setter
2. 共有属性直接操作时无法进行安全检查，而getter、setter方法可以灵活地进行重构升级，也可以在操作前进行安全检查

### 3.3使可变性最小化(最好是不可变类)

1. 不可变指的是类的实例不可变，其所包含的信息在初始化之后就不会再发生变化.jdk中提供了很多类都是不可变类String、Integer
2. 不可变类更容易设计使用，更加安全，也不会有线程并发问题

- 比如jdk中String不可变，因此jvm可以为他设计字符串池，并且HashMap等工具类也可以放心使用 String作为key
-
Integer不可变，因此可以设计—128～127的缓存，这样可以降低jvm的gc不可变类只需要考虑初始化时候的所有属性状态，而可变类需要随时考虑各种属性的可能变化，是否线程安全等问题，因此如果可以，设计为不可变类更安全高效，也更不容易出bug

3. 设计不可变类，有些需要注意的点

- 不要提供修改状态的方法 既然是不可变类，当然不应该提供修改状态的方法，如果需要其他状态，应该使用新的实例
- 避免类的扩展 如果类被子类继承，则可能部分行为被覆盖，这种情况是对不可变的破坏，应该避免此类被扩展，最简单直接的方式就是使用
  final 修饰类，禁止继承.当然也可以有其他方式，比如说，构造器私有化，通过静态方法对外提供实例，因为私有方法不能被外部访问（包括子类），这样虽然没有final
  修饰，但实际上也成了final类
- 属性final化对于一些关键的属性，设置为final，避免属性被修改
- 属性 private 化将属性私有化，可以避免外部直接操作，同时私有化之后可以更好处理未来的变化（公有的属性可能被任何外部类所使用，这会导致未来升级时，如果要保持兼容性，必须永远保留这个公有属性）
- 对可变组件的互斥访问如果类中有指向和使用可变对象，则不应该向调用者返回这些引用，也不能使用客户端提供的对象来初始化，也不要从任何访问方法中返回此引用.总之，如果不可变类使用了可变对象，应该保证自己不被这些可变所影响／在构造器，访问方法和
  readObject 中使用保护性拷贝
- （额外）数组和容器等尽量避免 getter方法，尽量避免在任何方法中返回这些对象这一条实际上是对上一条的补充，本质上是上一条的内容，这里额外说一下，因为数组和容器这些
  即便本身没有发生变化，如果你返回了引用，则可能被外部程序修改元素请参考StringBuilder和String的关系，对于不可变性和可变性的处理
- （额外）很多时候，坚固的堡垒却是被内部攻破，所以要注意一点，在避免上面的问题后，也要提醒自己，内部也不要修改属性和引用的信息

### 3.4复合优于继承

1. 继承是面向对象编程的重要特点，使用继承可以让我们方便地重用代码，但继承并不是适用于所有情况的，相反的是可能更多时候，复合比继承更合适

- 继承会破坏封装性（子类的某些特定功能可能依赖于父类的实现，而这样会导致父类的封装性被破坏，要么子类需要注意每一次父类的变化版本，要么父类被约束不能更新）

2. 比如我们使用的List、Map、Set等，如果要添加一个统计添加次数的功能因为原始类中没有，这时候如果我们用继承的方法去实现

### 3.5要么为继承而设计，并提供文档说明，要么就禁用继承

1. 继承是传播性的，使用继承必须考虑到所有的super中是否有影响
2. 合理暴露方法，需要认真设计好哪些方法应该是private 哪些protected 哪些
   public，因为任何public和protected方法都可能被继承（除非你声明final禁止指定方法被覆盖）
3. 方法之间如果有顺序或者依赖性，要考虑被覆盖后，是否会导致问题出现
4. 文档说明要及时准确，否则可能导致使用者错误的使用

- 继承当然不是一无是处，因为大部分情况下，我们的工作是小组的形式，而每个人有自己的大概维护范围，同时你也可以很方便找到他们，
  继承的缺点其实也不是一定会那么大，比如我们就经常设计BaseDao，BaseService，
  包括jdk也有非常多的继承的类，以上的说明只是帮我们认识到继承体系在极端情况下可能带来的问题，对这些东西有个心理预期
- 总之，合理利用继承，知道某些（很多）情况下，复合同样也可以解决我们的问题，不要只知道继承就可以了

### 3.6接口优于抽象类(建议性)

1. 关键字：接口interface、抽象类abstract class
2. 方法体：接口默认只能有方法定义，java9开始可以私有方法体、抽象类和普通类一样(需要声明abstract)
3. 权限：接口默认就是public、abstract修饰的方法不能有private和final
4. 实现方式：接口implements、抽象类extends
5. 并存性(混合性)：单继承多实现
6. 设计目的：接口定义抽象动作行为规范、抽象类用于抽取公共的父类实现

### 3.7接口只用于定义类型

在接口中，允许我们使用static final 关键字来定义一些常量，但这么做并不一定效果好，因为接口是用来定义行为的，接口自身不能做任何操作，
在接口中定义了常量会导致使用者迷惑，这些常量是用来做什么的？如果有了详尽的文档，让使用者知道了这些常量的意义，那又有另外一个问题，
接口升级时，如果不需要这些常量了怎么办，可以删除吗？要知道一个接口有时候有很多实现类，并且接口本来就是对外提供的，
你不知道接口到底被多少人多少程序在使用，贸然删除会导致使用者出现问题

1. 在实现类中实现
2. 如果一个常量与多个类相关，可以使用工具类或者枚举
3. 本条目的核心观点：职责分化，虽然jdk提供了接口静态变量的语法，但在合作开发中，尽量划清职责界限，属于谁的变量就交给谁，就像
   我们虽然可以在Number 中提供 LongMaxValue（Long类型的最大值），没有任何语法错误，但这显然不是好的实践

### 3.8类层次优于标签类

1. 当我们遇到一个基本类可能扩展出不同风格的时候，使用类层次要优于标签化
2. 标签类就是一个类中可能有多种情况，每种情况有各自的行为逻辑

### 3.9用函数对象表示策略(针对jdk8之前)

1. 对于一个函数，如有不同实现的需求，可以参考策略模式，接受一个自定义的参数，来允许调用者自定义底层基本方法，来完成上层复杂功能

### 3.10优先考虑静态成员类

1. 嵌套类有四种静态成员类、非静态成员类、匿名类、局部类，其中2、3、4叫做内部类
2. 一般来说 内部类的最常用的场景是作为外部类的辅助类，也就是他自身单独是没有什么作用的，他是辅佐外部类来实现功能的静态成员类特殊之处
3. 它被static修饰，所以它其实是属于class的，而没有被static修饰是属于实例的，非static成员类在实例化的时候需要先实例化外部类
4. 内部类一旦实例化，他就与外部类实例绑定，这种关系无法解绑，进而影响gc(一个不回收都不回收)


