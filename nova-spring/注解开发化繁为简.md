### 使用注解开发
前面我们已经了解了IoC容器和AOP实现，但是我们发现，要使用这些功能，我们就不得不编写大量的配置，这是非常浪费时间和精力的，并且我们还只是演示了几个小的例子，如果是像之前一样去编写一个完整的Web应用程序，那么产生的配置可能会非常多。能否有一种更加高效的方法能够省去配置呢？当然还是注解了。
所以说，第一步先把你的xml配置文件删了吧，现在我们全部使用注解进行开发（哈哈，是不是感觉XML配置白学了）

### 注解实现配置文件
那么，现在既然不使用XML文件了，那通过注解的方式就只能以实体类的形式进行配置了，我们在要作为配置的类上添加@Configuration注解，我们这里创建一个新的类MainConfiguration：
~~~java
@Configuration
public class MainConfiguration {
    //没有配置任何Bean
}
~~~
你可以直接把它等价于：
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
		
</beans>
~~~
那么我们来看看，如何配置Bean，之前我们是直接在配置文件中编写Bean的一些信息，现在在配置类中，我们只需要编写一个方法，并返回我们要创建的Bean的对象即可，并在其上方添加@Bean注解：
~~~java
@Configuration
public class MainConfiguration {
    @Bean
    public Card card() {
        return new Card();
    }
}
~~~
* spring自动装配bean
![](/Users/wangzehui/IdeaProjects/nova/nova-spring/src/main/picture/spring自动装配bean.jpeg)

除了像原来一样在配置文件中创建Bean以外，我们还可以直接在类上添加@Component注解来将一个类进行注册（现在最常用的方式），不过要实现这样的方式，我们需要添加一个自动扫描，来告诉Spring需要在哪些包中查找我们提供@Component声明的Bean。
只需要在配置类上添加一个@ComponentScan注解即可，如果要添加多个包进行扫描，可以使用@ComponentScans来批量添加。这里我们演示将bean包下的所有类进行扫描：
~~~java
@ComponentScan("com.nova.spring")
@Configuration
public class MainConfiguration {
}
~~~

我们可以看到IDEA的Spring板块中也显示了我们刚刚通过直接在类上添加@Component声明的Bean。
与@Component同样效果的还有@Controller、@Service和@Repository，但是现在暂时不提，讲到SpringMVC时再来探讨。
除了使用@Resource以外，我们还可以使用@Autowired（IDEA不推荐将其使用在字段上，会出现黄标，但是可以放在方法或是构造方法上），它们的效果是一样的，但是它们存在区别，虽然它们都是自动装配：

* @Resource默认ByName如果找不到则ByType，可以添加到set方法、字段上。
* @Autowired默认是byType，可以添加在构造方法、set方法、字段、方法参数上。

### 注解实现AOP操作
了解了如何使用注解注册Bean之后，我们接着来看如何通过注解实现AOP操作，首先我们需要在主类添加@EnableAspectJAutoProxy注解，开启AOP注解支持
~~~java
@EnableAspectJAutoProxy
@ComponentScan("com.nova.spring")
@Configuration
public class MainConfiguration {
    
}
~~~

### 其他注解配置
配置文件可能不止一个，我们有可能会根据模块划分，定义多个配置文件，这个时候，可能会出现很多个配置类，如果我们需要@Import注解来快速将某个类加入到容器中，比如我们现在创建一个新的配置文件，并将数据库Bean也搬过去：
~~~java
public class MysqlConfiguration {

    @Bean
    public Connection getConnection() throws SQLException {
        System.out.println("创建新的连接！");
        return DriverManager.getConnection("jdbc:mysql://ip:port/pay_center",
                "name",
                "password");
    }
}
~~~

~~~java
@EnableAspectJAutoProxy
@Configuration
@ComponentScan("com.nova.spring.config")
@Import({MysqlConfiguration.class, Date.class})
public class TestConfiguration {

    @Resource
    private Connection connection;

    @Resource
    private Date date;

    @PostConstruct
    public void init() {
        String format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date);
        System.out.println(format + " -> " + connection);
    }
}
~~~


可以看到，日期直接作为一个Bean放入到IoC容器中了，并且时间永远都是被new的那个时间，也就是同一个对象（因为默认是单例模式）。
通过@Import方式最主要为了实现的目标并不是创建Bean，而是为了方便一些框架的Registrar进行Bean定义，在讲解到Spring原理时，我们再来详细讨论，目前只做了解即可。
