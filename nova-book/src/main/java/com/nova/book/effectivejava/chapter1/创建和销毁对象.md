## 1.创建和销毁对象

### 1.1静态方法代替构造器(单例模式)
优点：  
1. 静态方法名称自由，可以描述构造行为。很多类需要不同的参数来执行不同功能，而且有些参数直接有冲突，或者互相之间又干扰，用setter容易出现非预期行为。  
2. 可以不必每次都新建。构造方法必然是new一个实例，但静态方法可以根据需要，创建新的实例还是返回已经创建过的实例。这里类似的Spring的＠Autowired 注解注入的时候就可以指定scope(prototype,request, session, singleton)  
3. 可以返回子类型，而构造器只能返回自身的新实例  
4. 参数组合清晰，使用者知道自己需要提供哪些参数组合，而很多功能细节就在这些参数中，这一点结合1来理解  
5. （个人）容易版本化，方法可以标记过时，然后删除，但构造器不方便，除非这个类完全不提供实例，那就不存在我们说的这一条建议了。  
6. 构造器之间互相调用有顺序要求，而静态方法之间无限制  

缺点:  
1. 影响自身的构造器和子类的行为。对于优点3，如果需要提供子类，第一自身的构造器不能只有private，如果子类没有在同一包中，则构造器不能是无修饰符。因为子类需要调用父类的构造器，则父类构造器不能private。同时，子类也需要根据父类的需求来定义构造器或者静态方法。所以，现在更多的是鼓励使用类的复合而不是继承  
2. 需要使用者知道哪些静态方法是提供构造功能的，有时候需要注释来辅助说明  
3. 静态方法不能访问实例变量  
4. 静态方法可能返回null  

### 1.2勾造器参数较多时，考虑用Builder(lombok开启builder)
>随着构造参数的增多，需要实例时如果用静态方法和构造器的组合就会急速膨胀，  
此时用Builder可以提供非常灵活地构建对象。我们当然可以使用setter来处理，但为了优化，  
我们希望有些属性成为final，一旦创建实例，就不再改变，这时候Builder的优势就是不可替代的了。
这种模式并不是一定就更好，只是我们需要知道这么一种设计模式，按需使用

优点：
1. 适用于多参数组合，只需要传递需要的参数（构造器如果参数比较多时，不方便全部枚举组合，  
只好提供最常用几种，并提供全参数组合，这时候可能你不得不提供一些非必要参数，即使不需要，也得传参），  
或者，选择使用无参，然后setter值，然后这样就使得参数处于可变状态，对象就是线程不安全的。于是使用者非常不便，Builder 模式就可以轻松处理这些问题

缺点：  
1. 需要先创建builder，在某些非常注重性能的地方不适合  
2. builder只有在参数很多时才合适，但有时候参数是逐渐攀升的，一开始可能就是用的构造器或静态方法，后期想改的时候已经在代码中铺开了，再改造可能要重构很多地方，或者就忍受丑陋的不一致现象以及维护成本，所以需要你提前就知道要使用builder模式

### 1.3用私有构造器或者枚举类型强化Singleton(jdk1.5之后用枚举)

### 1.4私有构造器强化不可实例化
应用于工具类，私有构造后，对外不能进行new了

### 1.5避免创建不必要的对象
1. new String("abc")
2. Integer num = 100;
3. 小对象的创建回收实际是很快的，有些时候为了代码清晰和可维护，我们会适当妥协。

### 1.6消除过期对象的引用
1. 要理解这个问题，需要理解jvm的垃圾回收机制，这里说的就是因为一些疏忽操作或定义，导致了部分数据一直无法被回收。这里可能对性能拖累不严重，但是却会占用更多资源，严重者导致oom。  
2. 资源未关闭问题，有些随着gc可能会被回收，有些则持续占用，但无论哪种，都可能严重拖累系统性能

### 1.7慎用(避免、禁止)使用终结方法
1. Object类的finalize方法
2. 此方法代表是终结，是对象将被回收的时候执行的操作
3. 不稳定性，他的实际执行时间是不可预期的
4. 如果确认使用这种设计，那就需要手动调用父类的finalize，否则会导致父类的方法被破坏
5. 可能影响性能

